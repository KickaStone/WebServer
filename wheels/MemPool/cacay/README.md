# C++ 内存池实现

## 前置知识

### std::allocator

C++ STL（标准模板库）中的分配器（Allocator）是一种用于控制内存分配和管理的工具。在STL中，分配器的设计旨在提供一种灵活和可替换的内存管理机制，使得用户可以根据需要自定义内存分配方式。

#### 基本原理

##### 1. 分配器的主要职责

分配器的主要职责包括：
- **内存分配**：请求和分配特定数量的内存。
- **内存释放**：释放之前分配的内存。
- **构造和析构对象**：在分配的内存上构造对象，以及在释放内存之前调用对象的析构函数。

##### 2. STL分配器的接口

C++中的分配器通常是一个类，具备以下几种基本成员函数：
- `allocate(size_t n)`：分配`n`个元素所需的内存空间，返回指向该内存的指针。
- `deallocate(T* p, size_t n)`：释放之前通过`allocate`分配的内存。
- `construct(T* p, Args&&... args)`：在分配的内存`p`上构造一个对象。
- `destroy(T* p)`：调用对象`p`的析构函数。

##### 3. 默认分配器

C++ STL提供了一个默认的分配器`std::allocator`，它使用操作系统的`new`和`delete`来进行内存管理。在大多数情况下，用户可以直接使用这个默认分配器。

##### 4. 自定义分配器

STL允许用户自定义分配器，以实现特定的内存管理策略。例如，用户可以实现一个池分配器，用于在小内存块的频繁分配和释放场景中提高性能。用户自定义的分配器需要满足STL的要求——实现相应的成员函数，并且能够与STL容器兼容。

##### 5. 分配器的使用

STL中的容器（如`std::vector`, `std::list`, 等）都允许在创建时指定分配器。例如，可以这样定义一个使用自定义分配器的`vector`：

```cpp
#include <vector>

template <typename T>
class MyAllocator {
    // 自定义分配器的实现
};

int main() {
    std::vector<int, MyAllocator<int>> myVector;
    // 使用myVector
}
```

##### 6. 适配器和类型特征

分配器还可以与其他C++特性结合使用，如适配器和类型特征，以增强功能和灵活性。例如，`std::allocator_traits`是一个用来简化分配器使用的工具，可以提供更好的适配和默认行为。

### 内存碎片问题

堆内存利用率低，主要是在各种程序执行时，频繁进行内存分配和释放引起的内存空间不连续的问题。主要分为**内碎片**和**外碎片**两种。内存碎片无法避免只能尽可能减少。

#### 内碎片
内碎片是指已分配的内存块未被实际使用的部分，就是请求多了没用到。
产生原因是：内存对齐会添加额外的内存，分配大小往往是4B/8B的整数倍

#### 外碎片
外碎片是指经过多次申请后，内存里未被利用的部分虽然很多，但由于不连续导致无法分配一个大的连续内存块。
产生原因：小内存块的申请和释放导致内存变得不连续


## 简单版本MemoryPool

来源: https://github.com/cacay/MemoryPool

只关注c++11 版本

#### MemoryPool.h

1.前面一堆类型定义`typedef`，是STL Allocator接口的标准要求，