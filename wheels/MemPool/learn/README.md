# 解析

## 池化

用资源换时间，预先准备足够的资源后，减少每次申请和释放资源的消耗。

## 内存池

### 作用 
1. 减少内存分配和释放开销
2. 减少内存碎片
3. 提高缓存命中率

### 演变

* 最简单的内存分配器

一个链表指向空闲内存，分配时取出一块，改写链表；释放时放回到链表内。
需要标记好避免二次释放；
优点：实现简单
缺点：分配时搜索合适的内存块效率低，释放归并消耗大，实际不实用

* 定长内存分配器

每个内存块大小固定，用链表连接起来。两个链表分别存放未分配和已分配的块。
请求和释放就是在两个链表之间移动。
优点：简单粗暴，分配释放效率高；
缺点：功能单一，只能解决定长内存需求，而且占着内存没有实际上释放

### hash FreeList 池

在定长的基础上，通过hash表映射不同长度块的链表
(8, 16, 32, 64...)

分配时根据需要查hash表，
优点：改进定长内存池，更适合不同大小的内存请求
缺点：存在内碎片问题；多线程并发锁竞争激烈，效率降低

## 内存池设计

整个内存池的内存块要设计成可以动态增长的。初始化时预先申请内存，不够用再申请一块内存和原来的拼起来，使用链表组织。

**内存块信息表：用来管理内存块**
```c++
struct memoryblock{
    int nsize;              
    int nfree;
    int nfirst;
    memoryblock *pnext;
    char adata[1];
};
```

其中`nsize`表示该块内存大小，`nfree`表示还有多少空闲单位可以被分配，`nfirst`表示第一个可分配单位的序号，`*pnext`是指向下一个内存块（申请新内存块的时候使用，`adata[1]`表示数据存储区的首地址。

内存池的主要任务就是管理内存块中的空闲单位，这里把所有空闲单位组织成链表，空闲单位的前2个字节表示下一个空闲单位的指针。
每个内存块的第一个空闲单位存储在`nfirst`里。这里不是真实的地址，而是一个序号，相当于内存块内部地址。

注意memoryblock其实是一个链表结构，在整个内存池里管理内存块是通过memorypool结构。

**内存池**

基本结构
![](./简易内存池.png)

```c++
struct memorypool
{
    int ninitsize;
    int ngrowsize;
    int nunitsize;
    memoryblock *pblock;
}
```
`ninitsize`是第一块的长度，`ngrowsize`是后新申请块的长度，`nunitsize`是块内存储单位的大小，这个应该能整除块的大小，最后就是内存块链表的指针。


### 实现

#### 柔性数组

内存块是一个整体，分配空间时, adata虽然是个char数组，但我们人为向后拓展了一块内存，用来作存储区，这是通过重载new运算符实现的。

> `adata`的地址其实就是内存块存储区的首地址。这样的用法其实叫作柔性数组。
如果将adata改成指针，释放内存的时候就需要两次释放，现在因为adata可变，就可以使用一次释放，直接把存储区的空间也释放掉。

> 系统在释放包含柔性数组的结构体时，并不需要知道柔性数组本身的大小，只需要释放当初 malloc 或 new 时分配的那块完整内存即可。

不同的内存块通过内存块中的`pnext`连接。
第一个内存块的地址同时也会存放在`memorypool`结构体的`pblock`里。

内存池的主要逻辑就是处理分配和释放内存，管理空闲内存单元。

这里实现的功能和特色有：
* 隐式空闲链表：利用内存单元自身存储链表指针，节省元数据空间
* LIFO策略：总是从链表头部分配，提升缓存命中率
* 块合并机制：当整个块空闲时自动释放，减少内存碎片
* 对齐优化：确保内存访问效率


#### 内存对齐

这里实现的方式是把要分配单元的大小取整到`MEMPOOL_ALIGNMENT`的整数倍，通过位运算
```c++
nunitsize = sizeof(T);
if (sizeof(T) > 4)
{
    nunitsize = (sizeof(T) + (MEMPOOL_ALIGNMENT - 1)) & ~(MEMPOOL_ALIGNMENT - 1); // 返回值为MEMPOOL_ALIGNMENT的倍数
}
else if (sizeof(T) > 2)
{
    nunitsize = (sizeof(T) + (MEMPOOL_ALIGNMENT - 1)) & ~(MEMPOOL_ALIGNMENT - 1);
}
else
{
    nunitsize = sizeof(T);
}
```

`(k+(n-1)) & ~(n-1)`
⁠`k + (n - 1)`：首先，我们将 `⁠k` 增加 `⁠n - 1`，这个操作的目的是将 `⁠k` 提高到下一个对齐块的边界。`⁠& ~(n - 1)`：然后，使用位与操作来清除掉 `⁠k + (n - 1)` 的低位，确保结果是对齐到 `⁠n` 的整数倍。

