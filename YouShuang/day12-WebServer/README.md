# 半同步/半反应堆线程池Web服务器

## 主要特点

- 基于半同步/半反应堆线程池
- HTTP报文解析

## 类
locker.h 封装了一些线程同步用的类（互斥锁，信号量，条件变量）
threadpool.h 简单线程池实现
http_conn 类，线程池的模板类，封装对逻辑任务的处理。
main函数


## http_conn类

这是项目中最麻烦的地方，不过之前已经解决了大部分http的解析了，


## DEBUG

### 1. errno 22 

表现：启动后直接打印error is 22
debug：
    main函数中只有一个位置打印这个错误，就是建立连接时，但服务器刚启动没有连接会建立。
    debug发现sockfd=listenfd，事件代码=16, 经过查询是`EPOLLHUP`事件。
    证明listenfd可以正常建立，epoll_wait调用时出现了挂断事件。
    使用cursor cladue模型检查代码，发现漏掉了`listen(listenfd, 5)`这一行代码, 如果没有使用`listen()`显式地将套接字标记为被动，套接字无法接受连接，并且epoll可能会立即发出EPOLLHUP（挂起）信号，因为套接字处于无法接受连接的无效状态。

    listen函数的主要功能是将一个原本用于主动连接的socket转变为被动监听状态，允许服务器端等待并接受来自客户端的连接请求.
解决方案： 增加漏掉的代码
如何避免： 多写代码，看着抄很容易抄漏

### 2. 只能请求1次（死锁）

表现：第二次请求会失败、无响应，无错误输出
debug：
    1. 首先解决epoll调试会中断问题
    2. 定位问题，观察日志和输出，第一次请求返回了正确的文件并正常关闭了连接，第二次连接发送后，并没有出现解析http请求报文的log，可以大致定位问题范围；
    3. 从建立连接开始调试，发现`users[sockfd].read()`可以正常执行，但下一步加入任务队列无法执行；
    4. 为了进一步确认问题，在这个函数内部添加了log，结果发现第二次请求，入队log也不打印，应该是append()代码执行有问题；
    5. 联系问题现象，和append任务代码，想到极有可能是出现死锁；果然代码出问题在`run`任务处理函数，申请了互斥锁确没有释放

    epoll 调试问题
    gdb 调试带有 epoll_wait 非正常返回 -1 ，要设置gdb调试的时候会在断点处插入一条中断指令,当程序执行到该断点处的时候会发送一个SIGTRAP信号,程序转去执行中断相应,进而gdb让程序停下来进行调试. 对于sem_wait\wait\read等会阻塞的函数在调试时,如果阻塞,都可能会收到调试器发送的信号,而返回非0值.
    为了解决这个问题需要在代码中忽略由于接收调试信号而产生的"错误"返回:
    ```c++
    if(  -1 == epoll_wait() )
    {
        if(errno!=EINTR)
        {
            return -1;
        }
    }
    ```
修改方案：明显又是照抄代码出现的问题，补上解锁语句即可。
如何避免：除了写代码仔细外，这个程序的log太少了，导致debug很困难，花费了大量的时间在找问题代码。
