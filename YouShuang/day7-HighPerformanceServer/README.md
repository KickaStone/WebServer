# 高性能服务器框架

## 服务器模型

1. C/S模型 
2. p2p模型

## 服务器编程基本框架

服务器主要由：
I/O 处理单元、逻辑单元、网络存储单元（可选）组成；
各单元使用请求队列通信，如果是机群也会用永久tcp连接通信；
请求队列是各单元之间通信方式的抽象，通常被实现为池的一部分。

## I/O模型

[I/O模型和高性能网络架构分析](https://www.cnblogs.com/S1mpleBug/p/16711860.html)


## 两种高效的事件处理模型

### Reactor模式

Reactor模式要求主线程（I/O处理单元）只负责监听文件描述上是否有事件发生，如果有的话立即将该事件通知工作线程（逻辑单元）。
除此之外，主线程不做任何其他性质的工作。读写数据，接受新的连接以及处理客户请求都由工作线程完成。

使用**同步I/O模型**（epoll_wait）的reactor模式的工作流程是：
1) 主线程往`epoll`内核事件表中注册socket上的读就绪事件。
2) 主线程调用`epoll_wait`等待socket上有数据可读
3) 当socket上有数据可读时，`epoll_wait`通知主线程，主线程则将socket可读事件放入请求队列
4) 睡眠在做请求队列上的模各工作线程被唤醒，它从socket上读数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件
5) 主线程调用`epoll_wait`等待socket可写
6) 当socket可写时，`epoll_wait`通知主线程。主线程将socket可写事件放入请求队列
7) 睡眠在请求队列上的模各工作线程被唤醒，它往socket上写入服务器处理客户请求的结果

![](https://pegasuswang.readthedocs.io/zh/latest/unix_linux/Linux高性能服务器编程/reactor.png)


### Proactor模式

使用异步I/O模型，以`aio_read`和`aio_write`为例实现的Proactor模式的工作流程是:

1) 主线程调用`aio_read`函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例）；

2) 主线程继续处理其他逻辑；

3) 当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序已经可用；

4) 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户需求。工作线程处理完客户请求之后，调用`aio_write`函数向内核注册socket上的写完成事件，并告诉内核用户缓冲区的位置，以及写操作完成时如何通知应用程序（信号）；

5) 主线程继续处理其他逻辑 ；

6) 当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕；

7) 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。

![](https://pegasuswang.readthedocs.io/zh/latest/unix_linux/Linux高性能服务器编程/proactor.png)